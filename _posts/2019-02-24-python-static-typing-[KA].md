# Python — სტატიკური სტილი

Python ცნობილია როგორც დინამიური პროგრამირების ენა რაც ნიშნავს იმას, რომ კოდის წერისას ცვლადებს ვქმნით დინამიურად, და არ გადავცემთ…

static typing in python

![](img/1__3gLRYu8pf2c4NLYWZVfgig.jpeg)

**Python** ცნობილია როგორც **დინამიური პროგრამირების ენა** რაც ნიშნავს იმას, რომ კოდის წერისას ცვლადებს ვქმნით დინამიურად, და არ გადავცემთ მონაცემებს იმის შესახებ თუ რა ტიპისაა ის. მონაცემის ტიპს **Python**\-ი თავისით განსაზღვრავს, გადაცემული მონაცემის მიხედვით:

![](img/1__9ffip8Gwjr1SfSUu__f5xrw.png)

ამ შემთხვევაში ცვლადი — **linux\_distribution** არის **str** ტიპის რადგან ჩვენ მას გადავეცით სტრიქონი, ხოლო **os\_version** შეიქმნა როგორც **int** ტიპის ცვლადი რადგან მნიშვნელობა, რომელიც მას მივანიჭეთ არის მთელი რიცხვი. მაგრამ **Python**\-მა ეს არ იცოდა მანამ სანამ კოდი არ გაეშვა.

მოდი შესადარებლად სხვა რომელიმე ენის მაგალითი მოვიყვანოთ, რომელიც სტატიკურად იწერება, მაგალითისთვის **Java**. იმისთვის, რომ აღნიშნული ცვლადები **Java**\-ში შევქმნათ, ცვლადის შექმნისას მოგვიწევს გადავცეთ მონაცემი იმის შესახებ, თუ რა ტიპის ცვლადია:

![](img/1__hknP1jGoCBroJ6MmL3bbHQ.png)

რადგან **Java**\-მ უკვე იცის, რომ **linux\_distribution** მხოლოდ უნდა შეიცავდეს სტრიქონს, ხოლო **os\_version** მხოლოდ უნდა შეიცავდეს მთელ რიცხვს, ისეთი მოქმედების შემთხვევაში როდესაც ვეცდებით, მაგალითად, მთელი რიცხვი შევინახოთ **linux\_distribution** -ში ან **os\_version** — ში სტრიქონი, კომპილაციისას მოგვცემს ერორს.

### **რატომ უნდა ვწერო Python-ი სტატიკურად?**

რა თქმა უნდა, **Python**\-ის დინამიურად წერის შემთხვევაში უფრო სწრაფად დავწერთ კოდს, არ მოგგვიწევს ცვლადის ტიპების ხელით განსაზღვრა. მაგრამ დიდი პროექტის შემთხვევაში უფრო რთულდება საქმე, შენ შეიძლება წააწყდე უამრავ ერორს, რომლებთან გამკლავებაშიც სტატიკურად ნაწერი **Python**\-ი დაგეხმარებოდა.

მოდი ხარვეზიანი, ერთი შეხედვით კარგი კოდის მაგალითი მოვიყვანოთ:

![](img/1____S__YyvXSvRM2__Jc0Pa3__lg.png)

აღნიშნულ კოდში, ყველაფერი რასაც ვაკეთებთ არის ის, რომ მომხარებელს ვეკითხებით მის სახელსა და პაროლს, და ვუბრუნებთ “გამარჯობა, <მომხარებლის სახელი>!”.

ამ პროგრამას თუ გავუშვებთ იდეალურად იმუშავებს იმ შემთხვაში თუ მომხარებლის სახელს, პაროლს ან ნებისმიერ რამეს შევიყვანთ… **მაგრამ** **ის დაიქრაშება** თუ არაფერს არ შევიყვანთ:

![](img/1__LdcR5MAxCnfk4EEVtzhjLA.png)

აღნიშნულ კოდში პრობლემა არის ის, რომ ცვლადი **default\_creds** არ არის სტრიქონი, ის არის ლექსიკონი (dictionary). ამიტომაც **get\_username** -ზე მისი გადაცემა საშინელი გადაწყვეტილებაა, რადგან ლექსიკონს არ აქვს .**split()** ფუნქცია.

რა თქმა უნდა მარტივად გამოსასწორებელი პრობლემაა, მაგრამ შეიძლება რთულად შევამჩნიოთ. შენ შეიძლება ამის შესახებ ვერ გაიგო, მანამ სანამ მომხარებელი არაფერს არ შეიყვანს და ისე დააწვება ენთერს.

კი რა თქმა უნდა, შეიძლება შენ დატესტე ეს კოდი უამრავჯერ მაგრამ ალბათ არასდროს გიცდია, რომ არ შეგეყვანა არაფერი და ისე დაგეჭირა ენთერზე.

სტატიკური წერა მსგავს ხარვეზს აგაცილებს, პროგრამის გაშვებამდე, ის გეტყვის რომ შენ არ შეგიძლია **get\_username**\-ს გადასცე **default\_creds** რადგან ის ელის **str** ტიპის ცვლადს, ხოლო რასაც შენ გადასცემ **Dict** ტიპისაა.

### **მოდი გამოვასწოროთ ჩვენი კოდი:**

განვანახლოთ ცვლადების ტიპები და თითოეული ფუნქციის მნიშვნელობები, რომლებსაც იღებს და აბრუნებს.

![](img/1__Q4SnHlawaqQO9NgzfxQzqg.png)

**Python**\-ის 3.6 ვერსიის ზევით ცვლადის შექმნა და ტიპის მინიჭება ხდება შემდეგნაირად:

> _ცვლადის\_სახელი: ტიპი = მნიშვნელობა_

> **creds : str = input(“**მომხარებლის სახელი და პაროლი გამოყავი : სიმბოლოთი**: “)**

> ხოლო ფუნქციის მნიშვნელობების, რომლებსაც იღებს და აბრუნებს - შემდეგნაირად:

> **def get\_username(creds : str) -> str:**

### **მოდი დავაყენოთ და გავუშვათ pypy (type checker):**

![](img/1__vrNbhcNoMQohUmF9R7cHFg.png)

კოდის გაშვების გარეშე ჩვენ ვიცით, რომ მეჩვიდმეტე ხაზზე შეცდომაა, ახლა შეგვიძლია მისი გამოსწორება მომხარებლის გარეშე, რომელსაც შეიძლებოდა რამდენიმე თვის შემდეგ შეემჩნია ეს პრობლემა.

რაც მთავარია, შენ თუ იყენებ პროგრამირების IDE-ს მაგალით PyCharm-ს ის ავტომატურად შეამოწმებს შენ კოდს და გამცნობს არსებული პრობლემის შესახებ.

![](img/1__mFhoRxkCuD6uHBVCJSsY3Q.png)

დიახ, ასეთი მარტივია!

### **მოდი კიდევ რამდენიმე მაგალითი განვიხილოთ:**

**str** და **int** ტიპის  ცვლადების შექმნა ძალიან მარტივია, მაგრამ თავის ტკივილი იწყება მაშინ როდესაც, უფრო კომპლექსურ კოდს წერ, მაგალითად მაშინ როცა სიებს(list) და ლექსიკონებს იყენებ.

მარტივი ფორმა რომლის გამოყენებაც სტატიკური წერისას გიწევს არის ის, რომ აიმპორტებ იმ ცვლადის ტიპებს, რომლებზეც მუშაობ:

![](img/1__bB__FK0rYwe20h__Lhyczj3w.png)

Tuple ცოტა უფრო განსხვავებულია რადგან ის გაძლევს უფლებას მისი თითოეული ელემენტის ტიპის განსაზღვრის. (Tuple არის ისეთი მონაცემთა სტრუქტურა, რომლის განახლების უფლებაც არ გვაქვს)

![](img/1__0L5NTiyBj7iPrcfPx9L9nw.png)

### **როგორ შევამოწმოთ სტატიკურად დაწერილი Python-ი?**

როდესაც Python-ი გაძლევს საშუალებას შექმნა ცვლადები სტატიკურად, სამწუხაროდ მას ამ დროისთვის არ შეუძლია შეგიმოწმოს კოდი. იმისთვის რომ სტატიკურად დაწერილი კოდი შეამოწმო, არის რამდენიმე ვარიანტი:

1\. დააყენო და გამოიყენო **mypy** პაკეტი, რომელიც უკვე ვახსენეთ ზემოთ და გაუშვათ ტერმინალიდან და შეამოწმებინოთ კოდი. დაყენება ძალიან მარტივია **pip** ის გამოყენებით, გახსენით ტერმინალი/ **cmd** და გაუშვით :

> **pip install mypy**

> ან

> **pip3 install mypy**

> გააჩნია კომპიუტერზე **Python**\-ის ნაგულისხმევი ვერსია 2\* ია თუ 3\*

2\. შენ შეგიძლია გამოიყენო **PyCharm** რომელიც თავისით მოგინიშნავს შეცდომას, ან რომელიმე ტექსტური ედიტორი რომელზეც ხელმისაწვდომია ისეთი **Plugin**\-ი რომელიც მიგანიშნებთ შეცდომაზე — მაგალითად **Atom/Sublime.**

მე გირჩევ რომ ორივე გამოიყენო, უყურო კოდს წერისას **PyCharm**\-ში ხოლო შემდეგ შეამოწმო ის **mypy**\-ს გამოყენებით რადგან შეიძლება **PyCharm**\-ში გამოგრჩეს რომელიმე ხარვეზი / ან მას გამორჩეს.

მადლობა პოსტის წაკითხვისთვის. Follow me, for future posts ❤ .

